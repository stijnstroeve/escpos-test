"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EscPosCompiler = void 0;
var iconv = require("iconv-lite");
var escposUtils_1 = require("./escposUtils");
var escposCommands_1 = require("./escposCommands");
var utils_1 = require("../utils");
var constants_1 = require("../constants");
var tableCompiler_1 = require("../table/tableCompiler");
var EscPosCompiler = /** @class */ (function () {
    function EscPosCompiler(options) {
        this.options = options;
    }
    EscPosCompiler.prototype.text = function (text, options) {
        options = options || {};
        if (options.newLine)
            text += '\n';
        var alignData = [];
        if (options.alignHT === 'left') {
            alignData = escposCommands_1.EscPos.TXT_ALIGN_LT;
        }
        else if (options.alignHT === 'center') {
            alignData = escposCommands_1.EscPos.TXT_ALIGN_CT;
        }
        else if (options.alignHT === 'right') {
            alignData = escposCommands_1.EscPos.TXT_ALIGN_RT;
        }
        var lineData = escposUtils_1.EscPosUtils.bufferToArray(iconv.encode(text, this.options.textEncoding || constants_1.DEFAULT_TEXT_ENCODING));
        var data = __spreadArray(__spreadArray(__spreadArray([], alignData, true), lineData, true), escposCommands_1.EscPos.TXT_ALIGN_LT, true);
        if (options.size) {
            if (options.size !== 0.5) {
                var sizeNumber = options.size - 1 + (options.size - 1) * 16;
                utils_1.Utils.prependAndAppendData(data, __spreadArray(__spreadArray([], escposCommands_1.EscPos.TXT_SIZE, true), [sizeNumber], false), escposCommands_1.EscPos.TXT_NORMAL);
            }
            else {
                // B is small font
                utils_1.Utils.prependAndAppendData(data, this.font('B'), escposCommands_1.EscPos.TXT_NORMAL);
            }
        }
        if (options.bold) {
            utils_1.Utils.prependAndAppendData(data, escposCommands_1.EscPos.TXT_BOLD_ON, escposCommands_1.EscPos.TXT_BOLD_OFF);
        }
        if (options.underline) {
            utils_1.Utils.prependAndAppendData(data, escposCommands_1.EscPos.TXT_UNDERL_ON, escposCommands_1.EscPos.TXT_UNDERL_OFF);
        }
        return data;
    };
    EscPosCompiler.prototype.getMaxCharsPerLine = function (size) {
        size = size || 1;
        if (size == 0.5)
            return this.options.fontBMaxChars;
        return this.options.fontAMaxChars / size;
    };
    EscPosCompiler.prototype.line = function (options) {
        if (options === void 0) { options = {}; }
        options.width = options.width || this.getMaxCharsPerLine(1);
        options.character = options.character || '─';
        if (options.character.length != 1) {
            options.character = '─';
        }
        var lineString = options.character.repeat(options.width) + '\n';
        return __spreadArray([], this.text(lineString), true);
    };
    EscPosCompiler.prototype.table = function (table) {
        var tableCompiler = new tableCompiler_1.TableCompiler(this);
        return tableCompiler.compileTable(table);
    };
    EscPosCompiler.prototype.barcode = function (barcode, options) {
        // TODO: For now we only support CODE128 barcodes, this should change in the future.
        var type = 'CODE128';
        if (type === 'CODE128') {
            barcode = '{B' + barcode;
        }
        // Default width = 2
        var width = (options === null || options === void 0 ? void 0 : options.width) || 2;
        // Default height = 64
        var height = (options === null || options === void 0 ? void 0 : options.height) || 64;
        if (![1, 2, 3].includes(width)) {
            throw new Error('Invalid barcode width (1-3)');
        }
        if (height < 1) {
            throw new Error('Barcode height cannot be less than 1');
        }
        else if (height > 255) {
            throw new Error('Barcode height cannot be more than 255');
        }
        if (barcode.length > 255) {
            throw new Error('Barcode is too long');
        }
        return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], escposCommands_1.EscPos.CTL_LF, true), escposCommands_1.EscPos.TXT_ALIGN_CT, true), escposCommands_1.EscPos.BARCODE_HEIGHT, true), [
            height
        ], false), escposCommands_1.EscPos.BARCODE_WIDTH, true), [
            width
        ], false), escposCommands_1.EscPos.BARCODE_FONT_A, true), escposCommands_1.EscPos.BARCODE_TXT_BLW, true), escposCommands_1.EscPos.BARCODE_CODE128, true), [
            // Barcode content
            barcode.length
        ], false), this.text(barcode), true), escposCommands_1.EscPos.TXT_ALIGN_LT, true), escposCommands_1.EscPos.CTL_LF, true);
    };
    EscPosCompiler.prototype.image = function (image, options) {
        options = options || {};
        var data = [];
        var header = escposCommands_1.EscPos.BITMAP_D24;
        var bitmap = image.toBitmap();
        var n = 3;
        // Set the line spacing to 0 so there will be no space between image lines.
        data.push.apply(data, this.lineSpacing(0));
        data.push.apply(data, this.text('\n'));
        for (var _i = 0, _a = bitmap.data; _i < _a.length; _i++) {
            var line = _a[_i];
            if (options.alignHT === 'center') {
                data.push.apply(data, escposCommands_1.EscPos.TXT_ALIGN_CT);
            }
            else if (options.alignHT === 'right') {
                data.push.apply(data, escposCommands_1.EscPos.TXT_ALIGN_RT);
            }
            else if (options.alignHT === 'left') {
                data.push.apply(data, escposCommands_1.EscPos.TXT_ALIGN_LT);
            }
            data.push.apply(data, header);
            data.push.apply(data, escposUtils_1.EscPosUtils.uInt16LE(line.length / n));
            data.push.apply(data, line);
            data.push.apply(data, this.text('\n'));
        }
        // Reset line spacing
        data.push.apply(data, this.lineSpacing());
        return data;
    };
    EscPosCompiler.prototype.linefeed = function (amount) {
        if (amount === void 0) { amount = 1; }
        var data = [];
        for (var i = 0; i < amount; i++) {
            data = data.concat(escposCommands_1.EscPos.CTL_LF);
        }
        return data;
    };
    EscPosCompiler.prototype.lineSpacing = function (space) {
        if (space == null) {
            // Reset the line spacing
            return escposCommands_1.EscPos.LS_DEFAULT;
        }
        else {
            return __spreadArray(__spreadArray([], escposCommands_1.EscPos.LS_SET, true), [space], false);
        }
    };
    EscPosCompiler.prototype.getSpacesForPercentage = function (percentage, textLength, size) {
        if (textLength === void 0) { textLength = 0; }
        if (size === void 0) { size = 1; }
        var amountOfSpaces = Math.floor(this.getMaxCharsPerLine(size) * (percentage / 100)) - textLength;
        if (amountOfSpaces < 1) {
            amountOfSpaces = 0;
        }
        return this.text(' '.repeat(amountOfSpaces), { size: size });
    };
    EscPosCompiler.prototype.font = function (font) {
        return font === 'A' ? escposCommands_1.EscPos.TXT_FONT_A : escposCommands_1.EscPos.TXT_FONT_B;
    };
    return EscPosCompiler;
}());
exports.EscPosCompiler = EscPosCompiler;
//# sourceMappingURL=escposCompiler.js.map