"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableCompiler = void 0;
var utils_1 = require("../utils");
var textCellData_1 = require("./celldata/types/textCellData");
var cellDataType_1 = require("./celldata/cellDataType");
var cellDataMap_1 = require("./celldata/cellDataMap");
var boxCellData_1 = require("./celldata/types/boxCellData");
var InvalidCellDataError = /** @class */ (function (_super) {
    __extends(InvalidCellDataError, _super);
    function InvalidCellDataError(message) {
        return _super.call(this, 'Invalid cell data type' + (message ? ': ' + message : '')) || this;
    }
    return InvalidCellDataError;
}(Error));
var TableCompiler = /** @class */ (function () {
    function TableCompiler(compiler) {
        this.compiler = compiler;
    }
    TableCompiler.prototype.getTextLinesFromCellData = function (row, column) {
        var cellData = row.data[column.key];
        var cellDataInstance;
        if (!cellData) {
            // For empty cells we use a default text an empty string
            cellDataInstance = new textCellData_1.TextCellData('');
        }
        else if (typeof cellData === 'string'
            || typeof cellData === 'number'
            || typeof cellData === 'boolean') {
            // By default, all cell data that is a string, a number or a boolean should be TextCellData's
            cellDataInstance = new textCellData_1.TextCellData(cellData.toString());
        }
        else if (typeof cellData === 'object' && !Array.isArray(cellData)) {
            // If the cell data is an object, but not an array, it should be a CellData object
            if (!('type' in cellData)) {
                throw new InvalidCellDataError('No "type" property found');
            }
            var _a = cellData, type = _a.type, data = _a.data;
            type = type.toString();
            if (!Object.values(cellDataType_1.CellDataType).includes(type)) {
                throw new InvalidCellDataError("Unknown type \"" + type + "\"");
            }
            cellDataInstance = TableCompiler.createCellDataFromType(type, data);
        }
        else {
            throw new InvalidCellDataError();
        }
        return {
            textLines: cellDataInstance.getTextLines(row, column, this),
            cellDataInstance: cellDataInstance
        };
    };
    TableCompiler.createCellDataFromType = function (type, data) {
        if (!(type in cellDataMap_1.default)) {
            return null;
        }
        return new cellDataMap_1.default[type](data);
    };
    TableCompiler.prototype.isLastRowForTextLines = function (table, cells, rowIndex) {
        var isLastArray = [];
        var _loop_1 = function (cI) {
            var cell = cells.find(function (c) { return c.row == rowIndex && c.column == cI; });
            isLastArray.push(cell ? cell.isLastTextLine : true);
        };
        for (var cI = 0; cI < table.columns.length; cI++) {
            _loop_1(cI);
        }
        return isLastArray.every(function (b) { return b; });
    };
    TableCompiler.prototype.getColumnCharacterWidth = function (textSize, columnWidth) {
        return Math.floor(this.compiler.getMaxCharsPerLine(textSize) * (columnWidth / 100));
    };
    TableCompiler.prototype.getTableCells = function (table) {
        var cells = [];
        var columns = table.columns.filter(function (c) { return c; }); // Only not empty columns
        var rows = table.rows.filter(function (r) { return r; }); // Only not empty rows
        var rowOffset = 0;
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            var localRowOffset = 0;
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                var row = rows[rowIndex];
                var column = columns[columnIndex];
                var columnCharWidth = this.getColumnCharacterWidth(row.size, column.width);
                var _a = this.getTextLinesFromCellData(row, column), textLines = _a.textLines, cellDataInstance = _a.cellDataInstance;
                if (cellDataInstance instanceof boxCellData_1.BoxCellData) {
                    row.lineSpacingLineWrap = 0;
                }
                for (var textLineIndex = 0; textLineIndex < textLines.length; textLineIndex++) {
                    var textLine = textLines[textLineIndex];
                    var cell = {
                        text: textLine,
                        isLastTextLine: textLineIndex === textLines.length - 1,
                        originalRow: rowIndex,
                        row: rowIndex + textLineIndex + rowOffset,
                        column: columnIndex,
                        charWidth: columnCharWidth,
                        style: {
                            bold: !!(column.bold || row.bold),
                            underline: !!row.underline,
                            align: column.alignHTRows || 'left'
                        }
                    };
                    cells.push(cell);
                }
                if (textLines.length > localRowOffset && textLines.length > 1) {
                    localRowOffset = textLines.length - 1;
                }
            }
            rowOffset += localRowOffset;
        }
        // Sort cells by row and column
        cells.sort(function (a, b) {
            if (a.row === b.row) {
                return a.column - b.column;
            }
            return a.row - b.row;
        });
        return cells;
    };
    TableCompiler.prototype.compileTableHeaders = function (table) {
        var _this = this;
        var data = [];
        var hasHeaders = table.columns.some(function (c) { return c.header; });
        if (hasHeaders) {
            var headerTextSize = 1;
            var _loop_2 = function (column) {
                // The default horizontal header alignment is left.
                if (!column.alignHTHeader)
                    column.alignHTHeader = 'left';
                // Check if the header isn't too long
                var headerWidth = this_1.getColumnCharacterWidth(headerTextSize, column.width);
                if (column.header && column.header.length > headerWidth) {
                    // Header is too long, add . at the end
                    column.header = column.header.substr(0, headerWidth - 1) + '.';
                }
                utils_1.Utils.orderedCallback(function () {
                    if (column.header) {
                        data.push.apply(data, _this.compiler.text(column.header, { bold: column.headerBold }));
                    }
                }, function () {
                    // Add the spaces
                    data.push.apply(data, _this.compiler.getSpacesForPercentage(column.width, column.header ? column.header.length : 0));
                }, column.alignHTHeader === 'left');
            };
            var this_1 = this;
            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                var column = _a[_i];
                _loop_2(column);
            }
            data.push.apply(data, this.compiler.text('\n'));
            // Add line between headers and rows
            data.push.apply(data, this.compiler.line());
        }
        return data;
    };
    TableCompiler.prototype.compileTableBody = function (table) {
        var _this = this;
        var data = [];
        var cells = this.getTableCells(table);
        var amountOfRows = cells.reduce(function (acc, cell) {
            return Math.max(acc, cell.row);
        }, 0);
        var _loop_3 = function (rI) {
            var isLastRow = this_2.isLastRowForTextLines(table, cells, rI);
            var addLineAfterRow = false;
            var _loop_4 = function (cI) {
                var cell = cells.find(function (c) { return c.row == rI && c.column == cI; });
                var column = table.columns[cI];
                if (cell) {
                    var row = table.rows[cell.originalRow];
                    var amountOfSpaces_1 = cell.charWidth - cell.text.length;
                    // Text options for the actual text to print
                    var textOptions_1 = {
                        bold: cell.style.bold,
                        underline: cell.style.underline,
                        size: row.size,
                    };
                    // Text options for the spaces after or before the text
                    var emptyTextOptions_1 = {
                        size: row.size,
                    };
                    // Line spacing
                    if (row.lineSpacingLineWrap !== undefined && !isLastRow) {
                        // For line wrapping
                        data.push.apply(data, this_2.compiler.lineSpacing(row.lineSpacingLineWrap));
                    }
                    else if (isLastRow && row.lineSpacing !== undefined) {
                        // For full rows
                        data.push.apply(data, this_2.compiler.lineSpacing(row.lineSpacing));
                    }
                    if (row.size === 0.5 && !isLastRow) {
                        // 0.5x size needs to have a lower line spacing, otherwise it will look odd.
                        data.push.apply(data, this_2.compiler.lineSpacing(20));
                    }
                    utils_1.Utils.orderedCallback(function () {
                        // If the cell is aligned to the left, the text will be added first. If it is aligned to the right, the spaces will be added first.
                        data.push.apply(data, _this.compiler.text(cell.text, textOptions_1));
                    }, function () {
                        data.push.apply(data, _this.compiler.text(' '.repeat(amountOfSpaces_1), emptyTextOptions_1));
                    }, cell.style.align === 'left');
                    if (row.line) {
                        addLineAfterRow = true;
                    }
                }
                else {
                    data.push.apply(data, this_2.compiler.text(' '.repeat(this_2.getColumnCharacterWidth(1, column.width))));
                }
            };
            for (var cI = 0; cI < table.columns.length; cI++) {
                _loop_4(cI);
            }
            data.push.apply(data, this_2.compiler.text('\n'));
            // Line after row
            if (addLineAfterRow && isLastRow) {
                data.push.apply(data, this_2.compiler.line());
            }
            // Reset line spacing
            data.push.apply(data, this_2.compiler.lineSpacing());
        };
        var this_2 = this;
        for (var rI = 0; rI < amountOfRows + 1; rI++) {
            _loop_3(rI);
        }
        return data;
    };
    TableCompiler.prototype.compileTable = function (table) {
        var data = [];
        data.push.apply(data, this.compileTableHeaders(table));
        data.push.apply(data, this.compileTableBody(table));
        return data;
    };
    return TableCompiler;
}());
exports.TableCompiler = TableCompiler;
//# sourceMappingURL=tableCompiler.js.map